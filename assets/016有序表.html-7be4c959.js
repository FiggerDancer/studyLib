import{_ as i,o as s,c as l,b as a,d as e,e as t}from"./app-72993491.js";const r={},n=a("h1",{id:"有序表",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#有序表","aria-hidden":"true"},"#"),e(" 有序表")],-1),h=a("h2",{id:"红黑树、avl、sb树",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#红黑树、avl、sb树","aria-hidden":"true"},"#"),e(" 红黑树、AVL、SB树")],-1),d=a("p",null,[e("操作时间复杂度 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"l"),a("mi",null,"o"),a("msub",null,[a("mi",null,"g"),a("mi",null,"N")]),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(log_{N})")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),a("span",{class:"mord mathnormal"},"o"),a("span",{class:"mord"},[a("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t vlist-t2"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.3283em"}},[a("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mtight"},[a("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.10903em"}},"N")])])])]),a("span",{class:"vlist-s"},"​")]),a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.15em"}},[a("span")])])])])]),a("span",{class:"mclose"},")")])])])],-1),c=t('<p>红黑树 AVL SB树 跳表 skip1:st</p><p>都是基于带有平衡操作的<!--  -->搜索二叉树</p><p>AVL最严格的平衡二叉树，任何一个节点，左右子树高度差不超过1。它利用了树的左旋和右旋两个动作完成了树的调整。</p><h3 id="左旋" tabindex="-1"><a class="header-anchor" href="#左旋" aria-hidden="true">#</a> 左旋</h3><figure><img src="https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806204729.png" alt="左旋" tabindex="0" loading="lazy"><figcaption>左旋</figcaption></figure><h3 id="检查时机" tabindex="-1"><a class="header-anchor" href="#检查时机" aria-hidden="true">#</a> 检查时机</h3><p>当插入/删除节点后，会从插入/删除节点开始往上每个节点查要一遍平衡性（删除节点如果左右两个孩子都有，需要从替换节点处开始查找）</p><h3 id="avl-特性" tabindex="-1"><a class="header-anchor" href="#avl-特性" aria-hidden="true">#</a> AVL 特性</h3><p>标记：height</p><h4 id="avl不平衡类型" tabindex="-1"><a class="header-anchor" href="#avl不平衡类型" aria-hidden="true">#</a> AVL不平衡类型</h4><p>LL、RR、LR、RL型</p><h5 id="avl平衡操作步骤" tabindex="-1"><a class="header-anchor" href="#avl平衡操作步骤" aria-hidden="true">#</a> AVL平衡操作步骤</h5><ol><li>LL右旋一次</li><li>RR左旋一次</li><li>LR，内部不平衡部分左旋，然后右旋</li><li>RL，内部不平衡部分右旋，然后左旋</li><li>更新节点高度</li></ol><h5 id="avl判断条件" tabindex="-1"><a class="header-anchor" href="#avl判断条件" aria-hidden="true">#</a> AVL判断条件</h5><ol><li>LL类型，左右树高度差大于1，且左子树存在左子树</li><li>LR类型，左右树高度差大于1，且左子树不存在左子树</li><li>RR类型，左右树高度差大于1，且右子树存在右子树</li><li>RL类型，左右树高度差大于1，且右子树不存在右子树</li></ol><h3 id="sizebalancetree-树特点" tabindex="-1"><a class="header-anchor" href="#sizebalancetree-树特点" aria-hidden="true">#</a> SizeBalanceTree 树特点</h3><p>标记：size</p><p>平衡性：<br> 每棵子树的大小，不小于其兄弟的子树大小<br> 既每棵叔叔树的大小，不小于其任何侄子树的大小具体实现与调整细节</p><figure><img src="https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806211919.png" alt="SizeBalanceTree" tabindex="0" loading="lazy"><figcaption>SizeBalanceTree</figcaption></figure><h4 id="sb-平衡操作步骤" tabindex="-1"><a class="header-anchor" href="#sb-平衡操作步骤" aria-hidden="true">#</a> SB 平衡操作步骤</h4><h5 id="ll-rr" tabindex="-1"><a class="header-anchor" href="#ll-rr" aria-hidden="true">#</a> LL/RR</h5><figure><img src="https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806212616.png" alt="LL" tabindex="0" loading="lazy"><figcaption>LL</figcaption></figure><ol><li>LL(左子树的左子树大于右子树) 对左子树右旋，记为m(T)</li><li>m(T) 递归判断</li><li>m(L)</li></ol><p>T的孩子节点发生变化了递归m(T)</p><h5 id="lr-rl" tabindex="-1"><a class="header-anchor" href="#lr-rl" aria-hidden="true">#</a> LR/RL</h5><figure><img src="https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806213025.png" alt="LR" tabindex="0" loading="lazy"><figcaption>LR</figcaption></figure><h5 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h5><figure><img src="https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806213221.png" alt="代码" tabindex="0" loading="lazy"><figcaption>代码</figcaption></figure><h3 id="红黑树的特点" tabindex="-1"><a class="header-anchor" href="#红黑树的特点" aria-hidden="true">#</a> 红黑树的特点</h3><ol><li>每个节点不是红就是黑</li><li>头部和底层的叶必须为黑（底层空的区域为叶节点）</li><li>任何两个红节点不能相邻</li><li>对于任何一颗子树来说，从某一个头部cur出发，到它的叶节点每一条路径要求黑节点数量一样</li></ol><p>保证路径长度的倍数关系没有到两倍以上</p><p>目前用处比较小，属于智力盛宴</p><h2 id="跳表" tabindex="-1"><a class="header-anchor" href="#跳表" aria-hidden="true">#</a> 跳表</h2><p>默认节点总是视为最小</p><p>任意一个数到来roll一个随机的层数，每次50%加一层，如果加一层后继续roll</p><figure><img src="https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806222315.png" alt="每层概率" tabindex="0" loading="lazy"><figcaption>每层概率</figcaption></figure><p>加一个数，利用高层加速，从高层开始找，找到小于它的最右节点</p><figure><img src="https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806221954.png" alt="加数，减数" tabindex="0" loading="lazy"><figcaption>加数，减数</figcaption></figure>',38),o=[n,h,d,c];function p(g,m){return s(),l("div",null,o)}const u=i(r,[["render",p],["__file","016有序表.html.vue"]]);export{u as default};
