# Vue

## Vue实现响应式的原理？（美图）

### 响应式的监听

不同于Vue2,Vue3中对于响应式做了升级，Vue2中主要使用Object.defineProperty的api来实现响应式，而Vue3中则主要依赖了ES6新增的Proxy和Reflect来实现响应式。在Vue2中我们使用Object.defineProperty是需要我们初始化时从上而下逐层遍历data中的每一个值的，而Vue3中则不需要这么做，Vue3只需要对最上层的一级进行代理即可，当访问到具体某个属性值时，再进一步的进行代理，这就大大减少了初始化时的开销和内存占用（因为构建依赖需要内存），再考虑到有些属性值可能根本不会访问到，这方面Vue2是没办法观察到的，而Vue3因为其按需构建响应式依赖的模式得以收益。此外Object.defineProperty返回的是对象本身，同时对数组对象API、Map、Set等Api支持并不好，而Proxy则是返回一个新的代理对象，同时能对各种Api的调用进行监听。值得一提的是，Vue2中为了支持数组的各种Api，对这些api都进行了重写，来达到响应式的效果。

### 响应式的依赖追踪

接下来我们谈一下响应式的依赖追踪，Vue的响应式追踪采用了观察者模式，首先他准备了一个activeEffect的值，记录当前的副作用，然后当Vue发现有值读取的时候，他会建立这个值和当前副作用的依赖，通过这样一种数据结构。

```ts
const targetMap = new WeakMap<any, KeyToDepMap>()
const depsMap = new Map()
const keyToDeps = new Set<ReactiveEffect>() // 用来收集effect
targetMap.set(key, depsMap) // 值 -> effects
keyToDeps.add(activeEffect)

```

而Vue第一次收集依赖也就是组件渲染的时候，渲染这个组件的同时，是要读取这个组件上要显示的这些动态值的。完事我接着往下走，上面是依赖的追踪，还有依赖的触发，当我们通过set的时候其实已经被Proxy或者Object.defineProperty捕获到了，这个时候呢会将这些依赖放入副作用队列里，并调用flush函数，flush函数是干嘛的就是执行副作用队列的所有副作用，然后把他们都删除掉，当在执行flush函数的时候不允许你加入新的副作用，flush函数执行完后会触发nextTick钩子，告诉你上次修改数据所产生的的副作用已经修改完了

## watch和watchEffect的区别和关系，你会怎么用（作业帮）

## vue-scoped的原理