# 打包资源处理

## 模块化方案

### cjs

cjs是nodejs的模块规范，通过require和exports进行导入导出，module.exports属于commonjs2。webpack也对cjs模块解析，所以cjs可以在nodejs和webpack下运行。现在不太流行

### esm

tc39对于ESMAScript的模块化规范，新版本node和现代浏览器都支持，也是未来趋势。使用import/export导入导出。因为esm是静态导入，所以可以在编译阶段tree shaking

::: warning

cjs模块输出的一个值的拷贝，esm输出的是值的引用  
cjs模块运行时加载，esm编译时加载  

:::

### cjs和esm使用差异

### cjs 和 esm差异

1. require  import  
2. module   export  
3. __dirname  
4. __filename  
5. exports export  

#### es实现 __dirname

```js
import { fileUrlToPath } from 'node:url'
import { dirname } from 'node:path'
const __dirname = dirname(fileUrlPath(import.meta.url))
```

#### es实现 __filename

```js
import { fileUrlToPath } from 'node:url'
const __filename = fileUrlPath(import.meta.url)
```

### umd

一种兼容cjs和amd的模块，可在node/webpack中用require使用，也可一直接用script引入

## AST

抽象语法树，应用很多如：ts->js,sass/less->css,es6+->es5,格式化，eslint，prettier，jsx，vue sfc

AST一般分三步

Code -> AST parse 词法分析生成Token、语法分析生成结构化的AST
AST -> AST transform 转化
AST -> Code generate 生成新代码

玩ast，有个好用的工具<https://astexplorer.net/>

### 实践

我做的一个英语题型库，里面的题干用了很多富文本的内容，比如说视频、音频、录音、填空题的空、ppt等，这些我是通过用一些特殊的html标签给标记出来。这个题型库最初是jquery的，后来技术栈迁移到vue上，我使用了dom操作的方式，在原先的dom节点上new Vue在挂上去，这种办法有个问题，就是排查问题，不太好排查，因为vue的根节点太多。然后我通过一个编译函数，编译这段html，生成ast结构，然后转化成我最后要生成的节点。在我写的vue富文本组件中，通过动态组件对于视频、音频、录音、填空题中的空、ppt使用我定义好的组件。

## 原理

### webpack runtime

1. `__webpack_modules__`: 维护一个所有模块的数组，将入口模块解析为AST，根据AST深度优先搜索所有的模块，并构建出这个模块数组，每个模块都由一个包裹函数`(module，__webpack_exports__ , __webpack_require__)` 对模块进行包裹构成, 如果module没人用就会变成 `__unused_webpack_module` 如果没有导出就会变成 `__unused_webpack_exports`
2. `__webpack_require__(moduleId)` 手动加载一个模块，对已加载模块缓存，对未加载模块，执行id定位 `__webpack_modules__` 中包裹的函数，执行并返回 `__webpack_exports__`
3. `__webpack_exports__`: 用于导出的对象
4. `__webpack_require__.r` 定义模块为es_module模块
5. `__webpack_require__.o` 判断对象是否包含某属性
6. `__webpack_require__.d` 定义导出变量
7. `__webpack_require__.e` 通过document.createElement('script')的方式异步加载chunk，并封装为Promise

#### 基础代码

```js
(() => {
    'use strict'
    var __webpack_modules__ = [
        (module, __webpack_exports__, __webpack_require__) => {
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, {
                add: () => (add)
            })
            function add(a, b) {
                return a + b
            }
        }
    ]
    var __webpack_cache_modules__ = {}
    var __webpack_require__ = (moduleId) => {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== undefined) {
            return cachedModule.exports;
        }
        // 创建一个exports
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        }
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        return module.exports
    }
    (() => {
       __webpack_require__.d = (exports, definition) => {
            for(var key in definition) {
                if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
                }
            }
        };
    })

    (() => {
        __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
    })();

    (() => {
        __webpack_require__.r = (exports) => {
            if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
            }
            Object.defineProperty(exports, '__esModule', { value: true });
        };
    })();

    var __webpack_exports__ = {}

    // 入口文件
    (() => {
        __webpack_require__.r(__webpack_exports__);
        var _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        function sub(a, b) {
            const min2ms = 60 * 1000
            const result = (0,_add__WEBPACK_IMPORTED_MODULE_0__.add)(min2ms, (0,_add__WEBPACK_IMPORTED_MODULE_0__.add)(a, b))
            console.log(result)
            return result
        }
        sub()
    })
})
```

#### 动态引入

```js
(() => {
    // 存储
    __webpack_require__.f = {};
    // 仅仅放在入口文件中
    __webpack_require__.e = (chunkId) => {
        return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
            __webpack_require__.f[key](chunkId, promises);
            return promises;
        }, []));
    };
})();

(() => {
    // 全局变量
    __webpack_require__.g = (function() {
        if (typeof globalThis === 'object') return globalThis;
        try {
            return this || new Function('return this')();
        } catch (e) {
            if (typeof window === 'object') return window;
        }
    })();
})();

(() => {
    // 这个工具函数用于引入异步模块
    __webpack_require__.u = (chunkId) => {
        // 返回基于模板的文件名
        // return url for filenames based on template
        return "" + chunkId + ".bundle.js";
    };
})();

(() => {
    var inProgress = {};
    var dataWebpackPrefix = "test-webpack:";
    // 加载一个script通过script标签
    __webpack_require__.l = (url, done, key, chunkId) => {
        if(inProgress[url]) { inProgress[url].push(done); return; }
        var script, needAttach;
        if(key !== undefined) {
            var scripts = document.getElementsByTagName("script");
            for(var i = 0; i < scripts.length; i++) {
                var s = scripts[i];
                if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
            }
        }
        if(!script) {
            needAttach = true;
            script = document.createElement('script');
            script.charset = 'utf-8';
            script.timeout = 120;
            if (__webpack_require__.nc) {
                script.setAttribute("nonce", __webpack_require__.nc);
            }
            script.setAttribute("data-webpack", dataWebpackPrefix + key);
            script.src = url;
        }
        inProgress[url] = [done];
        var onScriptComplete = (prev, event) => {
            // avoid mem leaks in IE.
            script.onerror = script.onload = null;
            clearTimeout(timeout);
            var doneFns = inProgress[url];
            delete inProgress[url];
            script.parentNode && script.parentNode.removeChild(script);
            doneFns && doneFns.forEach((fn) => (fn(event)));
            if(prev) return prev(event);
        }
        var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
        script.onerror = onScriptComplete.bind(null, script.onerror);
        script.onload = onScriptComplete.bind(null, script.onload);
        needAttach && document.head.appendChild(script);
    };
})();

(() => {
    var scriptUrl;
    if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
    var document = __webpack_require__.g.document;
    if (!scriptUrl && document) {
        if (document.currentScript)
            scriptUrl = document.currentScript.src;
            if (!scriptUrl) {
            var scripts = document.getElementsByTagName("script");
            if(scripts.length) {
                var i = scripts.length - 1;
                while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
            }
        }
    }
    // When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
    // or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
    if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
    scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
    __webpack_require__.p = scriptUrl;
})();

(() => {
    // no baseURI
    
    // object to store loaded and loading chunks
    // undefined = chunk not loaded, null = chunk preloaded/prefetched
    // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
    var installedChunks = {
        0: 0
    };
  
    __webpack_require__.f.j = (chunkId, promises) => {
        // JSONP chunk loading for javascript
        var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ?          installedChunks[chunkId] : undefined;
        if(installedChunkData !== 0) { // 0 means "already installed".
            // a Promise means "currently loading".
            if(installedChunkData) {
                promises.push(installedChunkData[2]);
            } else {
                if(true) { // all chunks have JS
                    // setup Promise in chunk cache
                    var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
                    promises.push(installedChunkData[2] = promise);
                    // start chunk loading
                    var url = __webpack_require__.p + __webpack_require__.u(chunkId);
                    // create error before stack unwound to get useful stacktrace later
                    var error = new Error();
                    var loadingEnded = (event) => {
                        if(__webpack_require__.o(installedChunks, chunkId)) {
                            installedChunkData = installedChunks[chunkId];
                            if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
                            if(installedChunkData) {
                                var errorType = event && (event.type === 'load' ? 'missing' : event.type);
                                var realSrc = event && event.target && event.target.src;
                                error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
                                error.name = 'ChunkLoadError';
                                error.type = errorType;
                                error.request = realSrc;
                                installedChunkData[1](error);
                            }
                        }
                    };
                    __webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
                }
            }
        }
    };
  
    // no prefetching
    
    // no preloaded
    
    // no HMR
    
    // no HMR manifest
    
    // no on chunks loaded
    
    // install a JSONP callback for chunk loading
    var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
        var [chunkIds, moreModules, runtime] = data;
        // add "moreModules" to the modules object,
        // then flag all "chunkIds" as loaded and fire callback
        var moduleId, chunkId, i = 0;
        if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
            for(moduleId in moreModules) {
                if(__webpack_require__.o(moreModules, moduleId)) {
                __webpack_require__.m[moduleId] = moreModules[moduleId];
                }
            }
            if(runtime) var result = runtime(__webpack_require__);
        }
        if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
        for(;i < chunkIds.length; i++) {
            chunkId = chunkIds[i];
            if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
                installedChunks[chunkId][0]();
            }
            installedChunks[chunkId] = 0;
        }
        
    }
    
    var chunkLoadingGlobal = self["webpackChunktest_webpack"] = self["webpackChunktest_webpack"] || [];
    chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
    chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
})();

__webpack_require__.e(/* import() */ 1).then(__webpack_require__.bind(__webpack_require__, 1)).then(({add}) => {
    const min2ms = 60 * 1000
    const result = add(min2ms, add(1, 2))
    console.log(result)
    return result
})
```

### rollup

rollup则直接合并两个文件，对于命名冲突，则直接使用变量重命名的方式解决问题

可以[点击这里](https://rollupjs.org/repl)玩
