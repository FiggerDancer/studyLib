# 打包资源处理

## 模块化方案

### cjs

cjs是nodejs的模块规范，通过require和exports进行导入导出，module.exports属于commonjs2。webpack也对cjs模块解析，所以cjs可以在nodejs和webpack下运行。现在不太流行

### esm

tc39对于ESMAScript的模块化规范，新版本node和现代浏览器都支持，也是未来趋势。使用import/export导入导出。因为esm是静态导入，所以可以在编译阶段tree shaking

::: warning

cjs模块输出的一个值的拷贝，esm输出的是值的引用  
cjs模块运行时加载，esm编译时加载  

:::

### umd

一种兼容cjs和amd的模块，可在node/webpack中用require使用，也可一直接用script引入

## AST

抽象语法树，应用很多如：ts->js,sass/less->css,es6+->es5,格式化，eslint，prettier，jsx，vue sfc

AST一般分三步

Code -> AST parse 词法分析生成Token、语法分析生成结构化的AST
AST -> AST transform 转化
AST -> Code generate 生成新代码

玩ast，有个好用的工具<https://astexplorer.net/>

### 实践

我做的一个英语题型库，里面的题干用了很多富文本的内容，比如说视频、音频、录音、填空题的空、ppt等，这些我是通过用一些特殊的html标签给标记出来。这个题型库最初是jquery的，后来技术栈迁移到vue上，我使用了dom操作的方式，在原先的dom节点上new Vue在挂上去，这种办法有个问题，就是排查问题，不太好排查，因为vue的根节点太多。然后我通过一个编译函数，编译这段html，生成ast结构，然后转化成我最后要生成的节点。在我写的vue富文本组件中，通过动态组件对于视频、音频、录音、填空题中的空、ppt使用我定义好的组件。

## 原理

### webpack runtime

1. `__webpack_modules__`: 维护一个所有模块的数组，将入口模块解析为AST，根据AST深度优先搜索所有的模块，并构建出这个模块数组，每个模块都由一个包裹函数`(module，__webpack_exports__ , __webpack_require__)` 对模块进行包裹构成, 如果module没人用就会变成 `__unused_webpack_module` 如果没有导出就会变成 `__unused_webpack_exports`

2. `__webpack_require__(moduleId)` 手动加载一个模块，对已加载模块缓存，对未加载模块，执行id定位 `__webpack_modules__` 中包裹的函数，执行并返回 `__webpack_exports__`
