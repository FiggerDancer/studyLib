# 有序表

## 红黑树、AVL、SB树

操作时间复杂度 $O(log_{N})$

红黑树 AVL SB树 跳表 skip1:st

都是基于带有平衡操作的<!--  -->搜索二叉树

AVL最严格的平衡二叉树，任何一个节点，左右子树高度差不超过1。它利用了树的左旋和右旋两个动作完成了树的调整。

### 左旋

![左旋](https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806204729.png)

### 检查时机

当插入/删除节点后，会从插入/删除节点开始往上每个节点查要一遍平衡性（删除节点如果左右两个孩子都有，需要从替换节点处开始查找）

### AVL 特性

标记：height

#### AVL不平衡类型

LL、RR、LR、RL型

##### AVL平衡操作步骤

1. LL右旋一次
2. RR左旋一次
3. LR，内部不平衡部分左旋，然后右旋
4. RL，内部不平衡部分右旋，然后左旋
5. 更新节点高度

##### AVL判断条件

1. LL类型，左右树高度差大于1，且左子树存在左子树  
2. LR类型，左右树高度差大于1，且左子树不存在左子树  
3. RR类型，左右树高度差大于1，且右子树存在右子树  
4. RL类型，左右树高度差大于1，且右子树不存在右子树  

### SizeBalanceTree 树特点

标记：size

平衡性：  
每棵子树的大小，不小于其兄弟的子树大小  
既每棵叔叔树的大小，不小于其任何侄子树的大小具体实现与调整细节  

![SizeBalanceTree](https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806211919.png)

#### SB 平衡操作步骤

##### LL/RR

![LL](https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806212616.png)

1. LL(左子树的左子树大于右子树) 对左子树右旋，记为m(T)
2. m(T) 递归判断
3. m(L)

T的孩子节点发生变化了递归m(T)

##### LR/RL

![LR](https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806213025.png)

##### 代码

![代码](https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806213221.png)

### 红黑树的特点

1. 每个节点不是红就是黑
2. 头部和底层的叶必须为黑（底层空的区域为叶节点）
3. 任何两个红节点不能相邻
4. 对于任何一颗子树来说，从某一个头部cur出发，到它的叶节点每一条路径要求黑节点数量一样

保证路径长度的倍数关系没有到两倍以上

目前用处比较小，属于智力盛宴

## 跳表

默认节点总是视为最小

任意一个数到来roll一个随机的层数，每次50%加一层，如果加一层后继续roll

![每层概率](https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806222315.png)

加一个数，利用高层加速，从高层开始找，找到小于它的最右节点

![加数，减数](https://cdn.jsdelivr.net/gh/lxy951101/chart-bed/assets20230806221954.png)
